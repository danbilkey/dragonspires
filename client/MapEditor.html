<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DragonSpires Map Editor</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #222;
            color: white;
            font-family: sans-serif;
        }
        #gameCanvas {
            border: 2px solid #666;
            display: block;
            margin: 0 auto;
        }
        .instructions {
            max-width: 640px;
            margin: 20px auto;
            background: #333;
            padding: 15px;
            border-radius: 5px;
        }
        .instructions h3 {
            margin-top: 0;
            color: #4CAF50;
        }
        .instructions p {
            margin: 5px 0;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="instructions">
        <h3>DragonSpires Map Editor</h3>
        <p><strong>Controls:</strong></p>
        <p>WASD - Move around the map</p>
        <p>1 - Switch to Floor Tile mode | 2 - Switch to Item mode</p>
        <p>R - Increase selected tile/item | E - Decrease selected tile/item</p>
        <p>Space - Place selected tile/item at current position</p>
        <p>G - Pick up (copy) the floor tile or item at current position</p>
        <p>P - Save map as newmap.json</p>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // ---------- CONFIG ----------
            const canvas = document.getElementById('gameCanvas');
            if (!canvas) { console.error('Missing <canvas id="gameCanvas">'); return; }
            const ctx = canvas.getContext('2d');

            const CANVAS_W = 640, CANVAS_H = 480;
            canvas.width = CANVAS_W; canvas.height = CANVAS_H;

            // Logical diamond for positioning
            const TILE_W = 64, TILE_H = 32;

            // Screen anchor for local tile
            const PLAYER_SCREEN_X = 430, PLAYER_SCREEN_Y = 142;

            // World/camera offsets
            const WORLD_SHIFT_X = -32, WORLD_SHIFT_Y = 16;
            const CENTER_LOC_ADJ_X = 32, CENTER_LOC_ADJ_Y = -8;
            const CENTER_LOC_FINE_X = -5, CENTER_LOC_FINE_Y = 0;

            // Chat areas
            const CHAT = { x1: 156, y1: 289, x2: 618, y2: 407, pad: 8 };

            // Constants
            const MAX_FLOOR_TILES = 99;
            const MAX_ITEMS = 345;

            // ---------- STATE ----------
            let tilesReady = false;
            let mapReady = false;
            let itemsReady = false;

            // Map data
            let mapSpec = { width: 64, height: 64, tiles: [], items: [] };
            
            // Player position
            let playerX = 32;
            let playerY = 32;
            
            // Editor state
            let editMode = 'floor'; // 'floor' or 'item'
            let selectedFloorTile = 1;
            let selectedItem = 0;
            
            // Chat messages
            let messages = ['Map Editor Loaded', 'Mode: Floor Tiles | Selected: Tile 1'];

            // ---------- ASSETS ----------
            const imgBorder = new Image();
            imgBorder.src = "/assets/game_border_2025.gif";
            let borderProcessed = null;
            imgBorder.onload = () => {
                try {
                    const w = imgBorder.width, h = imgBorder.height;
                    const off = document.createElement('canvas');
                    off.width = w; off.height = h;
                    const octx = off.getContext('2d');
                    octx.drawImage(imgBorder, 0, 0);
                    const data = octx.getImageData(0, 0, w, h);
                    const d = data.data;
                    for (let i = 0; i < d.length; i += 4) {
                        if (d[i] === 255 && d[i+1] === 0 && d[i+2] === 255) d[i+3] = 0;
                    }
                    octx.putImageData(data, 0, 0);
                    borderProcessed = off;
                } catch {
                    borderProcessed = null;
                }
            };

            // Floor tiles from /assets/floor.png: 9 columns x 11 rows, each 62x32, with 1px overlapping border
            const imgFloor = new Image();
            imgFloor.src = "/assets/floor.png";
            let floorTiles = []; // 1-based indexing
            imgFloor.onload = async () => {
                try {
                    const sheetW = imgFloor.width;
                    const sheetH = imgFloor.height;
                    const tileW = 62, tileH = 32;
                    const cols = 9;   // 9 columns
                    const rows = 11;  // 11 rows

                    const off = document.createElement('canvas');
                    off.width = sheetW; off.height = sheetH;
                    const octx = off.getContext('2d');
                    octx.drawImage(imgFloor, 0, 0);

                    let idCounter = 1;
                    const loadPromises = [];

                    for (let row = 0; row < rows; row++) {
                        for (let col = 0; col < cols; col++) {
                            const sx = 1 + (col * 63);  // 63 = 62 + 1 pixel border
                            const sy = 1 + (row * 33);  // 33 = 32 + 1 pixel border

                            const tcan = document.createElement('canvas');
                            tcan.width = tileW; tcan.height = tileH;
                            const tctx = tcan.getContext('2d', { willReadFrequently: true });
                            tctx.drawImage(off, sx, sy, tileW, tileH, 0, 0, tileW, tileH);

                            // magenta -> transparent (if present in art)
                            const imgData = tctx.getImageData(0, 0, tileW, tileH);
                            const d = imgData.data;
                            for (let i = 0; i < d.length; i += 4) {
                                if (d[i] === 255 && d[i+1] === 0 && d[i+2] === 255) d[i+3] = 0;
                            }
                            tctx.putImageData(imgData, 0, 0);

                            const tileImg = new Image();
                            const p = new Promise((resolve) => { tileImg.onload = resolve; tileImg.onerror = resolve; });
                            tileImg.src = tcan.toDataURL();
                            floorTiles[idCounter] = tileImg;
                            loadPromises.push(p);
                            idCounter++;
                        }
                    }

                    await Promise.all(loadPromises);
                    tilesReady = true;
                    console.log('Floor tiles loaded');
                } catch (e) {
                    console.error("Floor tile extraction failed:", e);
                    tilesReady = true;
                }
            };

            // Load items
            (() => {
                const imgItems = new Image();
                imgItems.src = "/assets/item.gif";

                const itemsJsonPromise = fetch("/assets/item.json")
                    .then(r => r.json())
                    .catch(() => null);

                const itemSprites = []; // 1-based
                const itemMeta = [];    // 1-based: { img, w, h, leftPad, anchorX }

                function waitImage(img) {
                    return new Promise((resolve) => {
                        if (img.complete) return resolve();
                        img.onload = resolve;
                        img.onerror = resolve;
                    });
                }

                Promise.all([waitImage(imgItems), itemsJsonPromise]).then(([_, meta]) => {
                    if (!meta || !Array.isArray(meta.item_coords)) return;

                    const off = document.createElement("canvas");
                    const octx = off.getContext("2d");

                    meta.item_coords.forEach((quad, idx) => {
                        const [sx, sy, sw, sh] = quad;
                        off.width = sw; off.height = sh;
                        octx.clearRect(0, 0, sw, sh);
                        octx.drawImage(imgItems, sx, sy, sw, sh, 0, 0, sw, sh);

                        // Make true magenta transparent + compute leftPad (first opaque column)
                        let leftPad = 0;
                        try {
                            const tempCanvas = document.createElement("canvas");
                            tempCanvas.width = sw; tempCanvas.height = sh;
                            const tempCtx = tempCanvas.getContext("2d", { willReadFrequently: true });
                            tempCtx.drawImage(off, 0, 0);
                            
                            const data = tempCtx.getImageData(0, 0, sw, sh);
                            const d = data.data;

                            // magenta -> transparent
                            for (let i = 0; i < d.length; i += 4) {
                                if (d[i] === 255 && d[i + 1] === 0 && d[i + 2] === 255) d[i + 3] = 0;
                            }

                            // find first opaque column from the left
                            leftPad = sw; // default "none found"
                            outer:
                            for (let x = 0; x < sw; x++) {
                                for (let y = 0; y < sh; y++) {
                                    const a = d[((y * sw) + x) * 4 + 3];
                                    if (a !== 0) { leftPad = x; break outer; }
                                }
                            }
                            if (leftPad === sw) leftPad = 0; // all transparent (safety)

                            tempCtx.putImageData(data, 0, 0);
                            octx.clearRect(0, 0, sw, sh);
                            octx.drawImage(tempCanvas, 0, 0);
                        } catch {
                            leftPad = 0; // fallback if canvas is tainted (shouldn't be here)
                        }

                        // Bottom-center anchor inside the sprite (relative to left edge)
                        const anchorX = (leftPad + (sw - 1)) / 2;

                        // Freeze the processed pixels into an <img>
                        const sprite = new Image();
                        sprite.src = off.toDataURL();

                        itemSprites[idx + 1] = sprite;
                        itemMeta[idx + 1] = { img: sprite, w: sw, h: sh, leftPad, anchorX };
                    });

                    itemsReady = true;
                    console.log('Items loaded');
                });

                // accessors
                window.getItemSprite = (i) => itemSprites[i] || null;
                window.getItemMeta   = (i) => itemMeta[i] || null;
                window.itemSpriteCount = () => itemSprites.length - 1;
                window.itemsReady = () => itemsReady;
            })();

            // Load initial map
            fetch('/client/map1.json')
                .then(r => r.json())
                .then(m => {
                    if (m && m.width && m.height) {
                        mapSpec = {
                            width: m.width,
                            height: m.height,
                            tiles: m.tiles ? JSON.parse(JSON.stringify(m.tiles)) : [],
                            items: m.items ? JSON.parse(JSON.stringify(m.items)) : []
                        };
                        
                        // Ensure tiles array is properly initialized with default tile 6
                        if (!mapSpec.tiles || mapSpec.tiles.length === 0) {
                            mapSpec.tiles = [];
                            for (let y = 0; y < mapSpec.height; y++) {
                                mapSpec.tiles[y] = new Array(mapSpec.width).fill(6);
                            }
                        } else {
                            // Fill any missing rows with default tile 6
                            for (let y = 0; y < mapSpec.height; y++) {
                                if (!mapSpec.tiles[y]) {
                                    mapSpec.tiles[y] = new Array(mapSpec.width).fill(6);
                                } else {
                                    // Fill any missing columns with default tile 6
                                    for (let x = 0; x < mapSpec.width; x++) {
                                        if (typeof mapSpec.tiles[y][x] === 'undefined') {
                                            mapSpec.tiles[y][x] = 6;
                                        }
                                    }
                                }
                            }
                        }
                        
                        // Ensure items array is properly initialized
                        if (!mapSpec.items || mapSpec.items.length === 0) {
                            mapSpec.items = [];
                            for (let y = 0; y < mapSpec.height; y++) {
                                mapSpec.items[y] = new Array(mapSpec.width).fill(0);
                            }
                        }
                        
                        console.log('Map loaded:', mapSpec);
                    }
                })
                .catch((e) => {
                    console.error('Failed to load map:', e);
                    // Create default map with tile 6
                    mapSpec.tiles = [];
                    mapSpec.items = [];
                    for (let y = 0; y < mapSpec.height; y++) {
                        mapSpec.tiles[y] = new Array(mapSpec.width).fill(6);
                        mapSpec.items[y] = new Array(mapSpec.width).fill(0);
                    }
                })
                .finally(() => { 
                    mapReady = true; 
                    console.log('Map ready');
                });

            // ---------- HELPER FUNCTIONS ----------
            function pushChat(line) { 
                messages.push(String(line)); 
                if (messages.length > 20) messages.shift(); 
            }

            function updateStatusMessage() {
                const mode = editMode === 'floor' ? 'Floor Tiles' : 'Items';
                const selected = editMode === 'floor' ? `Tile ${selectedFloorTile}` : `Item ${selectedItem}`;
                const statusMsg = `Mode: ${mode} | Selected: ${selected}`;
                
                // Replace the last status message if it exists
                if (messages.length > 1 && messages[messages.length - 1].startsWith('Mode:')) {
                    messages[messages.length - 1] = statusMsg;
                } else {
                    pushChat(statusMsg);
                }
            }

            function saveMap() {
                const mapData = {
                    width: mapSpec.width,
                    height: mapSpec.height,
                    tiles: mapSpec.tiles,
                    items: mapSpec.items
                };
                
                const jsonStr = JSON.stringify(mapData, null, 2);
                const blob = new Blob([jsonStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = 'newmap.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                pushChat('Map saved as newmap.json');
            }

            function isoBase(x, y) { 
                return { x: (x - y) * (TILE_W/2), y: (x + y) * (TILE_H/2) }; 
            }
            
            function isoScreen(x, y) {
                const base = isoBase(x, y);
                const camBase = isoBase(playerX, playerY);
                let screenX = PLAYER_SCREEN_X - TILE_W/2 + (base.x - camBase.x);
                let screenY = PLAYER_SCREEN_Y - TILE_H/2 + (base.y - camBase.y);
                screenX += WORLD_SHIFT_X + CENTER_LOC_ADJ_X + CENTER_LOC_FINE_X;
                screenY += WORLD_SHIFT_Y + CENTER_LOC_ADJ_Y + CENTER_LOC_FINE_Y;
                return { screenX, screenY };
            }

            function drawTile(sx, sy, t) {
                if (t > 0 && floorTiles[t]) {
                    ctx.drawImage(floorTiles[t], sx + 1, sy, 62, 32);
                } else {
                    ctx.beginPath();
                    ctx.moveTo(sx, sy + TILE_H/2);
                    ctx.lineTo(sx + TILE_W/2, sy);
                    ctx.lineTo(sx + TILE_W, sy + TILE_H/2);
                    ctx.lineTo(sx + TILE_W/2, sy + TILE_H);
                    ctx.closePath();
                    ctx.fillStyle = '#8DBF63';
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(0,0,0,0.25)';
                    ctx.stroke();
                }
            }

            function drawItemAtTile(sx, sy, itemIndex) {
                if (!window.getItemMeta || !window.itemsReady()) return;
                const meta = window.getItemMeta(itemIndex);
                if (!meta) return;

                const { img, w, h } = meta;
                if (!img || !img.complete) return;

                let drawX = (sx + TILE_W) - w;
                let drawY = (sy + TILE_H) - h;
                
                if (w < 62) {
                    const offsetX = w - 62;
                    drawX += offsetX;
                }
                
                if (h < 32) {
                    const offsetY = h - 32;
                    drawY += offsetY;
                }

                ctx.drawImage(img, drawX, drawY);
            }

            function drawPlayer() {
                const { screenX, screenY } = isoScreen(playerX, playerY);
                
                // Draw player name
                const nameX = screenX + TILE_W / 2 - 2;
                const nameY = screenY - 34;
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'center';
                ctx.lineWidth = 3; 
                ctx.strokeStyle = 'black'; 
                ctx.strokeText('Editor', nameX, nameY);
                ctx.fillStyle = 'white'; 
                ctx.fillText('Editor', nameX, nameY);
                ctx.lineWidth = 1;

                // Draw simple player representation
                ctx.fillStyle = '#1E90FF';
                ctx.beginPath();
                ctx.ellipse(screenX + TILE_W/2, screenY + TILE_H/2 - 6, 12, 14, 0, 0, Math.PI*2);
                ctx.fill();

                // Draw current selection preview under player
                if (editMode === 'floor' && selectedFloorTile > 0) {
                    // Draw selected floor tile with transparency
                    ctx.globalAlpha = 0.5;
                    drawTile(screenX, screenY, selectedFloorTile);
                    ctx.globalAlpha = 1.0;
                } else if (editMode === 'item' && selectedItem > 0) {
                    // Draw selected item with transparency
                    ctx.globalAlpha = 0.5;
                    drawItemAtTile(screenX, screenY, selectedItem);
                    ctx.globalAlpha = 1.0;
                }
            }

            function drawChatHistory() {
                const { x1, y1, x2, y2, pad } = CHAT;
                const w = x2 - x1;
                ctx.font = '12px monospace'; 
                ctx.fillStyle = '#000'; 
                ctx.textAlign = 'left';
                const lineH = 16;
                let y = y2 - pad;
                for (let i = messages.length - 1; i >= 0; i--) {
                    let line = messages[i];
                    while (ctx.measureText(line).width > w - pad*2 && line.length > 1) line = line.slice(0, -1);
                    ctx.fillText(line, x1 + pad, y);
                    y -= lineH;
                    if (y < y1 + pad) break;
                }
            }

            function drawCoordinates() {
                const { x1, y2 } = CHAT;
                ctx.font = '14px sans-serif';
                ctx.fillStyle = '#000';
                ctx.textAlign = 'left';
                ctx.fillText(`Position: (${playerX}, ${playerY})`, x1 + 8, y2 + 20);
            }

            // ---------- INPUT ----------
            window.addEventListener('keydown', (e) => {
                const k = e.key.toLowerCase();
                
                // Movement
                if (k === 'w' || k === 'arrowup') {
                    playerY = Math.max(0, playerY - 1);
                    e.preventDefault();
                } else if (k === 's' || k === 'arrowdown') {
                    playerY = Math.min(mapSpec.height - 1, playerY + 1);
                    e.preventDefault();
                } else if (k === 'a' || k === 'arrowleft') {
                    playerX = Math.max(0, playerX - 1);
                    e.preventDefault();
                } else if (k === 'd' || k === 'arrowright') {
                    playerX = Math.min(mapSpec.width - 1, playerX + 1);
                    e.preventDefault();
                }
                
                // Mode switching
                else if (k === '1') {
                    editMode = 'floor';
                    updateStatusMessage();
                    e.preventDefault();
                } else if (k === '2') {
                    editMode = 'item';
                    updateStatusMessage();
                    e.preventDefault();
                }
                
                // Selection cycling
                else if (k === 'r') {
                    if (editMode === 'floor') {
                        selectedFloorTile = Math.min(MAX_FLOOR_TILES, selectedFloorTile + 1);
                    } else {
                        selectedItem = Math.min(MAX_ITEMS, selectedItem + 1);
                    }
                    updateStatusMessage();
                    e.preventDefault();
                } else if (k === 'e') {
                    if (editMode === 'floor') {
                        selectedFloorTile = Math.max(1, selectedFloorTile - 1);
                    } else {
                        selectedItem = Math.max(0, selectedItem - 1);
                    }
                    updateStatusMessage();
                    e.preventDefault();
                }
                
                // Placement
                else if (k === ' ') {
                    if (!mapReady) return;
                    
                    if (editMode === 'floor') {
                        if (!mapSpec.tiles[playerY]) {
                            mapSpec.tiles[playerY] = new Array(mapSpec.width).fill(6);
                        }
                        mapSpec.tiles[playerY][playerX] = selectedFloorTile;
                        pushChat(`Placed floor tile ${selectedFloorTile} at (${playerX}, ${playerY})`);
                    } else {
                        if (!mapSpec.items[playerY]) {
                            mapSpec.items[playerY] = new Array(mapSpec.width).fill(0);
                        }
                        mapSpec.items[playerY][playerX] = selectedItem;
                        if (selectedItem === 0) {
                            pushChat(`Removed item at (${playerX}, ${playerY})`);
                        } else {
                            pushChat(`Placed item ${selectedItem} at (${playerX}, ${playerY})`);
                        }
                    }
                    e.preventDefault();
                }
                
                // Pick up (copy existing tile/item to current selection)
                else if (k === 'g') {
                    if (!mapReady) return;
                    
                    if (editMode === 'floor') {
                        const currentTile = (mapSpec.tiles && mapSpec.tiles[playerY] && typeof mapSpec.tiles[playerY][playerX] !== 'undefined') ? mapSpec.tiles[playerY][playerX] : 6;
                        selectedFloorTile = Math.max(1, Math.min(MAX_FLOOR_TILES, currentTile));
                        pushChat(`Picked up floor tile ${selectedFloorTile} from (${playerX}, ${playerY})`);
                        updateStatusMessage();
                    } else {
                        const currentItem = (mapSpec.items && mapSpec.items[playerY] && typeof mapSpec.items[playerY][playerX] !== 'undefined') ? mapSpec.items[playerY][playerX] : 0;
                        selectedItem = Math.max(0, Math.min(MAX_ITEMS, currentItem));
                        pushChat(`Picked up item ${selectedItem} from (${playerX}, ${playerY})`);
                        updateStatusMessage();
                    }
                    e.preventDefault();
                }
                
                // Save
                else if (k === 'p') {
                    saveMap();
                    e.preventDefault();
                }
            });

            // ---------- RENDER ----------
            function render() {
                ctx.clearRect(0, 0, CANVAS_W, CANVAS_H);
                ctx.fillStyle = '#0a0a0a'; 
                ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);

                if (tilesReady && mapReady) {
                    // Draw floor tiles
                    for (let y = 0; y < mapSpec.height; y++) {
                        for (let x = 0; x < mapSpec.width; x++) {
                            const t = (mapSpec.tiles && mapSpec.tiles[y] && typeof mapSpec.tiles[y][x] !== 'undefined') ? mapSpec.tiles[y][x] : 6;
                            const { screenX, screenY } = isoScreen(x, y);
                            drawTile(screenX, screenY, t);
                        }
                    }
                    
                    // Draw items
                    if (itemsReady) {
                        for (let y = 0; y < mapSpec.height; y++) {
                            for (let x = 0; x < mapSpec.width; x++) {
                                const itemId = (mapSpec.items && mapSpec.items[y] && typeof mapSpec.items[y][x] !== 'undefined') ? mapSpec.items[y][x] : 0;
                                if (itemId > 0) {
                                    const { screenX, screenY } = isoScreen(x, y);
                                    drawItemAtTile(screenX, screenY, itemId);
                                }
                            }
                        }
                    }
                    
                    // Draw player
                    drawPlayer();
                }

                // Draw border
                if (borderProcessed) {
                    ctx.drawImage(borderProcessed, 0, 0, CANVAS_W, CANVAS_H);
                } else if (imgBorder && imgBorder.complete) {
                    ctx.drawImage(imgBorder, 0, 0, CANVAS_W, CANVAS_H);
                }

                // Draw chat
                drawChatHistory();
                
                // Draw coordinates
                drawCoordinates();
                
                requestAnimationFrame(render);
            }
            
            render();
        });
    </script>
</body>
</html>
